## Паттерны проектировия
Какие бывают?

Порождающие паттерны
Структурные паттерны
Поведенческие паттерны

### Порождающие патерны

## Фабричный метод

Фабричный метод — это пораждающий шаблон проектирования, используемый для создания конкретных реализаций общего интерфейса.
Он позволяет разделить процесс создания объекта от кода, который зависит от интерфейса объекта.
Например, приложению требуется объект с определенным интерфейсом. 
Это может объект у которого конкретная реализация интерфейса зависит от некоторого параметра.
Вместо того, чтобы использовать сложную условную структуру  if/elif/else  для выбора конкретной реализации, приложение делегирует это решение отдельному компоненту, который создает объект. 
При таком подходе код приложения упрощается, что делает его более удобным для повторного использования и обслуживания.

## Абстрактная фабрика
Идея очень похожа на обычный шаблон фабрики, единственное отличие состоит в том, 
что все фабрики имеют несколько отдельных методов для создания объектов, и тип фабрики определяет семейство объектов.

Абстрактная фабрика отвечает за создание целых групп объектов, наряду с их соответствующими фабриками, — 
но она не касается конкретных реализаций этих объектов. Эта часть оставлена для их соответствующих фабрик:

## Строитель
Представьте что вам нужно создать робота. Робот может быть гуманоидным с четырьмя конечностями и стоящим вертикально, или он может быть похож на животное с хвостом, крыльями и т. д.
Он может использовать колеса, чтобы двигаться, или он может использовать лопасти вертолета. Он может использовать камеры, инфракрасный модуль обнаружения т.д..
А теперь представьте себе какой может быть конструктор для такого объекта:
```
def __init__(self, left_leg, right_leg, left_arm, right_arm,
             left_wing, right_wing, tail, blades, cameras,
             infrared_module, #...
             ):
    self.left_leg = left_leg
    if left_leg == None:
        bipedal = False
    self.right_leg = right_leg
    self.left_arm = left_arm
    self.right_arm = right_arm
    # ...
```
Создание этого класса было бы крайне нечитаемым, было бы очень легко ошибиться в некоторых типах аргументов, так как мы работаем в Python, 
и можем накапливать бесчисленное количество аргументов в конструкторе. Кроме того, что если мы не хотим, 
чтобы робот реализовал все поля в классе? Что если мы хотим, чтобы у него были только ноги, а не ноги и колеса?
Python не поддерживает перегруженные конструкторы, которые помогли бы нам определить такие случаи 
(и даже если бы мы могли, это привело бы только к еще более грязным конструкторам).

## Прототип
Допустим нам нужно клонировать объект, но мы можем не знать его точный тип и его параметры. 
Все они могут быть назначены не в конструкторе или могут зависеть от состояния системы в конкретной точке во время выполнения.
Если мы попытаемся сделать это напрямую, мы добавим много ветвей зависимостей в наш код, и в итоге это может не сработать.

Шаблон проектирования Prototype решает проблему копирования объектов путем делегирования этой задачи самим объектам. 
Все объекты, которые можно копировать, должны реализовать метод clone и использовать его для получения точных копий самих себя.

Шаблон Prototype может быть действительно полезен в крупномасштабных приложениях, которые создают множество объектов. 
Иногда копирование уже существующего объекта обходится дешевле, чем создание нового.

## Сингтон
Singleton — это объект с двумя основными характеристиками:
Нельзя создавать более одного экземпляра этого объекта
Он должен быть доступен в любом месте программы

Оба эти свойства важны, хотя на практике вы часто слышите, как люди называют что-то синглтоном, 
даже если у него есть только одно из этих свойств. Наличие только одного экземпляра обычно является механизмом управления 
доступом к некоторому общему ресурсу. Например, два потока могут работать с одним и тем же файлом, поэтому вместо того, 
чтобы открывать его по отдельности, Singleton может предоставить им уникальную точку доступа.

Глобальная доступность важна, потому что после того, как ваш класс был создан один раз, 
вам нужно будет передать этот единственный экземпляр для работы с ним. И не всегда такое возможно будет повторить. 
Вот почему легче убедиться, что всякий раз, когда вы снова пытаетесь создать экземпляр класса, вы просто получаете тот же экземпляр, который у вас уже был.

## Пул Объектов
Допустим у нас есть класс в нашем проекте, который называется MyClass. MyClass очень полезен для нас и мы его часто 
используем на протяжении всего проекта, хотя и в течение коротких периодов времени. Однако его создание и инициализация очень дороги, 
и наша программа работает очень медленно, потому что ей постоянно нужно создавать новые экземпляры, чтобы использовать 
их только для нескольких операций.

Мы можем создать пул объектов, при этом сами объекты будут создавать при создании пула. 
Всякий раз, когда нам нужно использовать объект типа MyClass, мы будем получать его из пула, далее использовать его, 
а затем перемещать обратно в пул для повторного использования.

Если объект имеет какое-то начальное состояние по умолчанию, освобождение всегда будет перезапускать его.