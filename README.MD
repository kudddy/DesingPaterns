## Паттерны проектировия
Какие бывают?

Порождающие паттерны
Структурные паттерны
Поведенческие паттерны

### Порождающие патерны

## Фабричный метод

Фабричный метод — это пораждающий шаблон проектирования, используемый для создания конкретных реализаций общего интерфейса.
Он позволяет разделить процесс создания объекта от кода, который зависит от интерфейса объекта.
Например, приложению требуется объект с определенным интерфейсом. 
Это может объект у которого конкретная реализация интерфейса зависит от некоторого параметра.
Вместо того, чтобы использовать сложную условную структуру  if/elif/else  для выбора конкретной реализации, приложение делегирует это решение отдельному компоненту, который создает объект. 
При таком подходе код приложения упрощается, что делает его более удобным для повторного использования и обслуживания.

## Абстрактная фабрика
Идея очень похожа на обычный шаблон фабрики, единственное отличие состоит в том, 
что все фабрики имеют несколько отдельных методов для создания объектов, и тип фабрики определяет семейство объектов.

Абстрактная фабрика отвечает за создание целых групп объектов, наряду с их соответствующими фабриками, — 
но она не касается конкретных реализаций этих объектов. Эта часть оставлена для их соответствующих фабрик:

## Строитель
Представьте что вам нужно создать робота. Робот может быть гуманоидным с четырьмя конечностями и стоящим вертикально, или он может быть похож на животное с хвостом, крыльями и т. д.
Он может использовать колеса, чтобы двигаться, или он может использовать лопасти вертолета. Он может использовать камеры, инфракрасный модуль обнаружения т.д..
А теперь представьте себе какой может быть конструктор для такого объекта:
```
def __init__(self, left_leg, right_leg, left_arm, right_arm,
             left_wing, right_wing, tail, blades, cameras,
             infrared_module, #...
             ):
    self.left_leg = left_leg
    if left_leg == None:
        bipedal = False
    self.right_leg = right_leg
    self.left_arm = left_arm
    self.right_arm = right_arm
    # ...
```
Создание этого класса было бы крайне нечитаемым, было бы очень легко ошибиться в некоторых типах аргументов, так как мы работаем в Python, 
и можем накапливать бесчисленное количество аргументов в конструкторе. Кроме того, что если мы не хотим, 
чтобы робот реализовал все поля в классе? Что если мы хотим, чтобы у него были только ноги, а не ноги и колеса?
Python не поддерживает перегруженные конструкторы, которые помогли бы нам определить такие случаи 
(и даже если бы мы могли, это привело бы только к еще более грязным конструкторам).

## Прототип
Допустим нам нужно клонировать объект, но мы можем не знать его точный тип и его параметры. 
Все они могут быть назначены не в конструкторе или могут зависеть от состояния системы в конкретной точке во время выполнения.
Если мы попытаемся сделать это напрямую, мы добавим много ветвей зависимостей в наш код, и в итоге это может не сработать.

Шаблон проектирования Prototype решает проблему копирования объектов путем делегирования этой задачи самим объектам. 
Все объекты, которые можно копировать, должны реализовать метод clone и использовать его для получения точных копий самих себя.

Шаблон Prototype может быть действительно полезен в крупномасштабных приложениях, которые создают множество объектов. 
Иногда копирование уже существующего объекта обходится дешевле, чем создание нового.

## Сингтон
Singleton — это объект с двумя основными характеристиками:
Нельзя создавать более одного экземпляра этого объекта
Он должен быть доступен в любом месте программы

Оба эти свойства важны, хотя на практике вы часто слышите, как люди называют что-то синглтоном, 
даже если у него есть только одно из этих свойств. Наличие только одного экземпляра обычно является механизмом управления 
доступом к некоторому общему ресурсу. Например, два потока могут работать с одним и тем же файлом, поэтому вместо того, 
чтобы открывать его по отдельности, Singleton может предоставить им уникальную точку доступа.

Глобальная доступность важна, потому что после того, как ваш класс был создан один раз, 
вам нужно будет передать этот единственный экземпляр для работы с ним. И не всегда такое возможно будет повторить. 
Вот почему легче убедиться, что всякий раз, когда вы снова пытаетесь создать экземпляр класса, вы просто получаете тот же экземпляр, который у вас уже был.

## Пул Объектов
Допустим у нас есть класс в нашем проекте, который называется MyClass. MyClass очень полезен для нас и мы его часто 
используем на протяжении всего проекта, хотя и в течение коротких периодов времени. Однако его создание и инициализация очень дороги, 
и наша программа работает очень медленно, потому что ей постоянно нужно создавать новые экземпляры, чтобы использовать 
их только для нескольких операций.

Мы можем создать пул объектов, при этом сами объекты будут создавать при создании пула. 
Всякий раз, когда нам нужно использовать объект типа MyClass, мы будем получать его из пула, далее использовать его, 
а затем перемещать обратно в пул для повторного использования.

Если объект имеет какое-то начальное состояние по умолчанию, освобождение всегда будет перезапускать его.

### Поведенческий паттерн


## Цепочка обязанностей
Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно 
по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

## Команда
Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как 
аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
Аналогия из жизни:
Вы заходите в ресторан и садитесь у окна. К вам подходит вежливый официант и принимает заказ, записывая все пожелания в блокнот. Откланявшись, он уходит на кухню, где вырывает лист из блокнота и клеит на стену. Далее лист оказывается в руках повара, который читает содержание заказа и готовит заказанные блюда.

В этом примере вы являетесь отправителем, официант с блокнотом — командой, а повар — получателем. 
Как и в паттерне, вы не соприкасаетесь напрямую с поваром. 
Вместо этого вы отправляете заказ с официантом, который самостоятельно «настраивает» повара на работу. 
С другой стороны, повар не знает, кто конкретно послал ему заказ. Но это ему безразлично, 
так как вся необходимая информация есть в листе заказа.

## Итератор
Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, 
не раскрывая их внутреннего представления.

Аналогия из жизни:
Вы планируете полететь в Рим и обойти все достопримечательности за пару дней. Но приехав, вы можете долго петлять узкими улочками, пытаясь найти Колизей.

Если у вас ограниченный бюджет — не беда. 
Вы можете воспользоваться виртуальным гидом, скачанным на телефон, который позволит отфильтровать только интересные вам точки.
А можете плюнуть и нанять локального гида, который хоть и обойдётся в копеечку, но знает город как свои пять пальцев, и сможет посвятить вас во все городские легенды.

Таким образом, Рим выступает коллекцией достопримечательностей, а ваш мозг, 
навигатор или гид — итератором по коллекции. Вы, как клиентский код, можете выбрать один из итераторов, отталкиваясь от решаемой задачи и доступных ресурсов.

## Посредник
Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, 
благодаря перемещению этих связей в один класс-посредник.
Аналогия из жизни:
Пилоты садящихся или улетающих самолётов не общаются напрямую с другими пилотами. Вместо этого они связываются с диспетчером, 
который координирует действия нескольких самолётов одновременно. 
Без диспетчера пилотам приходилось бы все время быть начеку и следить за всеми окружающими самолётами самостоятельно, 
а это приводило бы к частым катастрофам в небе.

Важно понимать, что диспетчер не нужен во время всего полёта. 
Он задействован только в зоне аэропорта, когда нужно координировать взаимодействие многих самолётов.

## Снимок
Снимок — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, 
не раскрывая подробностей их реализации.

## Наблюдатель
Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам 
следить и реагировать на события, происходящие в других объектах.

После того как вы оформили подписку на газету или журнал, вам больше не нужно ездить в супермаркет и проверять, 
не вышел ли очередной номер. Вместо этого издательство будет присылать новые номера по почте прямо к вам домой сразу после их выхода.

Издательство ведёт список подписчиков и знает, кому какой журнал высылать. 
Вы можете в любой момент отказаться от подписки, и журнал перестанет вам приходить.

## Состояние

Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. 
Извне создаётся впечатление, что изменился класс объекта.

Паттерн Состояние предлагает создать отдельные классы для каждого состояния, в котором может пребывать объект, 
а затем вынести туда поведения, соответствующие этим состояниям.

Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый контекстом, 
будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.